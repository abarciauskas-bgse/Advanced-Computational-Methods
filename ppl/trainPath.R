# train.digit should take a digit (which is a list of attributes for a digit as generated by the thinning procecure, I think)
#   generates a path and then return a vector of probabilities and the label of the digit
train.digit <- function(digit) {
  label <- digit$label
  # create the path
  digit.train <- generatePaths(list(digit))
  # also return number of long strokes
  digit.num.real.strokes <- sum(sapply(digit.train[[1]]$direction.steps, length) >= 8)

  # find the longest path
  digit.steps <- digit.train[[1]]$direction.steps[[which.max(sapply(digit.train[[1]]$direction.steps, length))]]
  digit.total.steps <- length(digit.steps)
  digit.steps.probabilities <- rep(0, 8)

  for (step.type in 1:8) {
    # find number of times step happened in the first stroke
    digit.steps.probabilities[step.type] <- sum(digit.steps == step.type)/digit.total.steps
  }

  # also the number of strokes
  return(list(
    step.probs = digit.steps.probabilities,
    label = label,
    total.steps = digit.total.steps,
    num.real.strokes = digit.num.real.strokes))
}

