---
title: "Bayesian Program Learning: MNIST Data Set"
author: "Aimee Barciauskas & Miquel Torrens"
date: "March 2, 2016"
output: pdf_document
---

Bayesian Programming Learning of Hand-Drawn Integers

[ADD ME: SHOW EXAMPLES]
0
1
2
3
4
5
6
7
8
9

1. Create thinned image
2. Generate directed path

Directed path enables:

1. New integer generation
2. Prediction?

## Creating the thinned image

```{r}
if (!require('grid')) install.packages('grid')
if (!require('prodlim')) install.packages('prodlim')
if (!require('igraph')) install.packages('igraph')
if (!require('RColorBrewer')) install.packages('RColorBrewer')
if (!require('scales')) install.packages('scales')

setwd('~/Box Sync/abarciausksas/myfiles/Advanced Computational Methods/data/')
digits <- read.csv('MNIST_training.csv')

source('~/Box Sync/abarciausksas/myfiles/15D012 Advanced Computational Methods/datasets/MNIST/displayDigit.R')
source('~/Box Sync/abarciausksas/myfiles/Advanced Computational Methods/ppl/utils.R')


source('~/Box Sync/abarciausksas/myfiles/Advanced Computational Methods/ppl/thinPoints.R')
source('~/Box Sync/abarciausksas/myfiles/Advanced Computational Methods/ppl/allThinnedInts.R')
# for 1000 points this took 3 minutes? that seems wrong
system.time(thinned.ints <- all.thinned.ints(digits[1:100,]))
```

Make sure things worked:

```{r}
rand.idcs <- sample(1:length(thinned.ints),10)
for (i in rand.idcs) {
  plot(thinned.ints[[i]]$points, main = paste0('Hey, this is a: ', thinned.ints[[i]]$label), pch = 19, ylim = c(-16,0), xlim = c(0,16))
  Sys.sleep(0.5)
}
```

Can we compare lengths?

```{r}
colors <- brewer.pal(11,'Spectral')

int.lengths <- lapply(thinned.ints, function(num) {
  c(num$label, num$num.pixels)
})

(int.lengths.mat <- matrix(unlist(int.lengths), nrow = length(int.lengths), ncol = 2, byrow = TRUE))
int.lengths.mat <- data.frame(na.omit(int.lengths.mat))
colnames(int.lengths.mat) <- c('label', 'num.pixels')

plot(int.lengths.mat$num.pixels ~ int.lengths.mat$label, pch = 19, col = alpha(colors[[9]], 0.1))

boxplot(int.lengths.mat$num.pixels ~ int.lengths.mat$label, pch = 19, col = alpha(colors[[9]], 0.5))
```

Looks like we can predict based on length a bit.

```{r}
source('../ppl/relativePosition.R')
source('../ppl/addPaths.R')

dev.off()
rand.idcs <- sample(1:length(thinned.ints),10)
# FIXME: preforms poorly if too many points - maybe rethin?
thinned.ints.with.paths <- generatePaths(thinned.ints[rand.idcs], animation = TRUE)

for (i in 1:length(thinned.ints.with.paths)) {
  plot(thinned.ints.with.paths[[i]]$points, pch = 19, ylim = c(-16,0), xlim = c(0,16))
  points(thinned.ints.with.paths[[i]]$path, pch = 19, col = 'red')
  Sys.sleep(1)
}
```

Generating new digits

```{r}

int.loops <- lapply(all.thinned.ints, function(num) {
  c(num$label, num$loops)
})

int.loops.mat <- matrix(unlist(int.loops), nrow = length(int.loops), ncol = 2, byrow = TRUE)
plot(int.loops.mat[,1], int.loops.mat[,2], pch = 19)

for (idx in 1:length(all.thinned.ints)) {
  d <- all.thinned.ints[[idx]][['path']]
  # in a 16x16 image, a point is positioned at the absolute value of y - 1 + x
  d.points <- apply(d, 1, function(pt) { (16*abs(pt[2])-1)+pt[1] })
  mat <- matrix(0, nrow = 16, ncol = 16)
  for (i in 1:256) {
    if (i %in% d.points) {
      row.idx <- i %/% 16 + 1
      col.idx <- i %% 16
      mat[row.idx,col.idx] <- 1
    }
  }
  d <- graph.adjacency(mat)
  g <- minimum.spanning.tree(d)

  features <- as.numeric(t(mat))
  # displaying the original digit
  displayDigit(features, all.thinned.ints[[idx]]$label, newDevice = FALSE)
  Sys.sleep(1)
}
```